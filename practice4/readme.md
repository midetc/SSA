## ЗАВДАННЯ 1:

### Умова:
Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

### Пояснення та опис програми:

У цьому завданні ми досліджуємо, скільки пам’яті можна запитати у malloc(3) за один виклик. Оскільки параметр malloc має тип size_t, найгірший випадок—передати йому максимальне значення, яке може умістити цей беззнаковий цілочисельний тип. На 64‑бітній платформі size_t займає 8 байтів (64 біти), тому теоретично найбільше число, яке можна передати, — це 2^64 – 1. Це еквівалентно приблизно 18 446 744 073 709 551 615 байтам, тобто близько 16 ексабайт

Щоб перевірити це на практиці, можна написати простий тест: спочатку вивести sizeof(size_t) і її максимум через printf("%zu\n", (size_t)-1), а потім спробувати виклик malloc(max_size_t) та подивитися, чи виділення вдасться. На реальних системах практичний максимум значно менший через системні обмеження ОС: доступну віртуальну та фізичну пам’ять, налаштування ulimit і політики керування пам’яттю. У типовому Linux-кернелі програми рідко можуть перевищити кілька гігабайт чи терабайт, незважаючи на теоретичні 16 ексабайт.

Таким чином, навіть якщо malloc(3) формально приймає до 2^64 – 1 байт, реальні ліміти залежатимуть від ресурсів машини, конфігурації ядра та обмежень користувача.

## ЗАВДАННЯ 2:

### Умова:
Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.
### Пояснення та опис програми:
На скрінах видно як malloc(3) реагує на некоректні розміри – від’ємні та ті, що виникають через переповнення. Спочатку ми передаємо -1, і бачимо помилку «malloc failed for negative size: Cannot allocate memory», бо -1 перетворюється в size_t як SIZE_MAX, що одразу перевищує доступну пам’ять. Далі множимо INT_MAX на 2 в типі int, отримуємо -2 через переповнення й знову отримуємо NULL від malloc, бо просимо гігантський блок. Нарешті працюємо з беззнаковим size_t: беремо половину максимуму й множимо на 3, що знову переповнює й дає велике значення total; malloc(total) також повертає NULL. На скриншоті видно, що незалежно від архітектури (x64 чи x32) усі три виклики завершуються помилкою, і програма виводить діагностичні повідомлення через perror. Це підтверджує: malloc не захищає від переповнення аргументів, але безліч запитуваної пам’яті завжди призводить до відмови.
### Результати:

![](task2/task2.png)
## [Код завдання](task6/task6.c)
