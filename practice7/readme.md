## ЗАВДАННЯ 1:

### Умова:
 Використайте popen(), щоб передати вивід команди rwho (команда UNIX) до more (команда UNIX) у програмі на C.
### Пояснення та опис програми:
У звичайній системі результат rwho читається через popen("rwho","r") і передається в more через popen("more","w"), а потім по рядку копіюється з одного потоку в інший. Проблема в тому, що на нашій віртуалці rwho не показує жодних рядків, бо там немає запущеного демона rwhod. Щоб усе протестувати, ми імітуємо його вивід: відкриваємо процес more для запису й у циклі генеруємо 100 рядків із текстом "simulated rwho output". Оскільки рядків більше, ніж вміщується на один екран, more автоматично зупиняється на першій “сторінці” і виводить --More--. Таким чином переконуємося, що popen() правильно відкриває зовнішній процес, а more обробляє вхід посторінково.\

### Результати:

![](task1/task1_1.png)
### [Код завдання](task1/task.c)



## ЗАВДАННЯ 2:

### Умова:
 Напишіть програму мовою C, яка імітує команду ls -l в UNIX — виводить список усіх файлів у поточному каталозі та перелічує права доступу тощо.
 (Варіант вирішення, що просто виконує ls -l із вашої програми, — не підходить.)
### Пояснення та опис програми:
Програма відкриває поточний каталог через opendir() і читає всі записи readdir(), пропускаючи приховані (ім’я починається з '.'). Для кожного файлу викликається stat(), щоб отримати struct stat із набором метаданих. Функція print_mode() перетворює поле st_mode на рядок із 10 символів: тип (d для директорії, l для символічного лінку, - для звичайного файлу) і три потрійні набори прав (rwx) для власника, групи й інших. Імена власника та групи отримуються через getpwuid() та getgrgid(). Час останньої модифікації форматують у стилі %b %e %H:%M (наприклад, Jun  4 14:12). Нарешті всі поля виводяться через printf() у тому ж порядку, як у ls -l.
Для порівняння вивели ls -l.
### Результати:

![](task2/task2.png)
### [Код завдання](task2/task.c)




## ЗАВДАННЯ 3:

### Умова:
 Напишіть програму, яка друкує рядки з файлу, що містять слово, передане як аргумент програми (проста версія утиліти grep в UNIX).
### Пояснення та опис програми:
Програма бере з командного рядка перше слово як шаблон, другий аргумент – ім’я текстового файлу. Вона відкриває файл у режимі читання й у циклі построково читає його в буфер buf (розміром 4096 байт). Для кожного рядка виконує перевірку strstr(buf, argv[1]) – шукає підрядок. Якщо рядок містить шаблон, виводить цей рядок на стандартний вихід. Таким чином отримуємо функціонал, аналогічний простому grep word filename, але без виклику зовнішніх команд.
Для порівняння вивели grep pattern input.txt В обох випадках програма повинна видати однаковий список рядків.
### Результати:

![](task3/task3.png)
![](task3/task3_2.png)
### [Код завдання](task3/task.c)






## ЗАВДАННЯ 4:

### Умова:
 Напишіть програму, яка виводить список файлів, заданих у вигляді аргументів, з зупинкою кожні 20 рядків, доки не буде натиснута клавіша (спрощена версія утиліти more в UNIX).
### Пояснення та опис програми:
Програма бере аргументи як імена файлів і в циклі відкриває кожен через fopen(). Потім рядок за рядком читає вміст за допомогою fgets(), виводить його на стандартний вихід і рахує, скільки рядків показано. Коли лічильник досягає 20, програма друкує підказку --More-- і чекає getchar()—будь‑який символ від користувача—перш ніж продовжити. Після завершення виведення одного файлу вона переходить до наступного.
Припустимо, у вас є два файли:
file1.txt (30 рядків) і file2.txt (15 рядків).
Перші 20 рядків файлу 1 виводяться одразу, потім програма зупиняється на --More-- і продовжує після натискання клавіші. Після останнього рядка першого файлу вона відразу починає друкувати file2.txt, теж зупиняючись по 20 рядків (якщо б там їх було більше).
### Результати:

![](task4/task4_1.png)
![](task4/task4_2.png)
### [Код завдання](task4/task.c)





## ЗАВДАННЯ 5:

### Умова:
 Напишіть програму, яка перелічує всі файли в поточному каталозі та всі файли в підкаталогах.
### Пояснення та опис програми:
Програма стартує з виклику listdir("."), тобто з поточного каталогу. Всередині listdir відкриваємо каталог за допомогою opendir, потім у циклі читаємо записи readdir, пропускаючи . та ... Для кожного запису будуємо повний шлях через snprintf, виконуємо stat — щоб дізнатися, чи об’єкт є каталогом чи файлом.
Якщо це підкаталог, рекурсивно викликаємо listdir з новим шляхом — і обходимо його вміст. Інакше (звичайний файл) просто друкуємо його шлях у відносному від поточного каталогу вигляді ./.../ім’я_файлу.

Таким чином у результаті ми обійдемо все дерево каталогів і виведемо всі шляхи до файлів.
### Результати:

![](task5/task5.png)
### [Код завдання](task5/task.c)




## ЗАВДАННЯ 6:

### Умова:
 Напишіть програму, яка перелічує лише підкаталоги у алфавітному порядку.
### Пояснення та опис програми:
Програма відкриває поточний каталог через opendir(".") і перебирає всі записи з readdir(), пропускаючи . і ... Для кожного запису будується шлях ./<імʼя>, після чого stat() перевіряє, чи є це каталогом. Якщо так, ім’я каталогу зберігається в динамічному масиві рядків, розмір якого за потреби збільшується через realloc(). Після збору всіх імен масив сортується з допомогою qsort() й стандартної strcmp(). Нарешті, відсортовані імена виводяться послідовно через printf(), а пам’ять підрядків і масиву звільняється.
### Результати:

![](task6/task6.png)
### [Код завдання](task6/task.c)




## ЗАВДАННЯ 7:

### Умова:
 Напишіть програму, яка показує користувачу всі його/її вихідні програми на C, а потім в інтерактивному режимі запитує, чи потрібно надати іншим дозвіл на читання (read permission); у разі ствердної відповіді — такий дозвіл повинен бути наданий.
### Пояснення та опис програми:
Програма відкриває поточний каталог і послідовно переглядає всі записи через readdir(), відбираючи тільки ті, що закінчуються на .c і є звичайними файлами (перевірка через stat()). Далі вона виводить англійське запитання для кожного файлу і читає одну відповідь getchar(), очищаючи буфер. Якщо користувач вводить y або Y, виконується chmod(), яке додає біт S_IROTH до поточних прав, і виводиться підтвердження успішної зміни. Інші відповіді ігноруються, після чого каталог закривається.
На скріншотах видно кінцевий результат, дозвіл на читання коректно надавася
### Результати:

![](task7/task7.png)
### [Код завдання](task7/task.c)




## ЗАВДАННЯ 8:

### Умова:
 Напишіть програму, яка надає користувачу можливість видалити будь-який або всі файли у поточному робочому каталозі. Має з’являтися ім’я файлу з запитом, чи слід його видалити.
### Пояснення та опис програми:
Програма відкриває поточний каталог, перебирає всі записи та для кожного звичайного файлу запитує в користувача, чи видаляти його. Відповідь читається через getchar(), далі очищається залишок рядка. Якщо введено y або Y, викликається unlink(), і файл видаляється; в іншому разі програма просто переходить до наступного. Після обробки всіх файлів каталог закривається, і програма завершує роботу.
### Результати:

![](task8/task8.png)
### [Код завдання](task8/task.c)




## ЗАВДАННЯ 9:

### Умова:
 Напишіть програму на C, яка вимірює час виконання фрагмента коду в мілісекундах.
### Пояснення та опис програми:
Програма виконує такі кроки. Спочатку зчитує поточний час у змінну start через clock_gettime(CLOCK_MONOTONIC). Далі виконує фрагмент коду (тут — порожній цикл з 100 млн ітерацій). Після завершення циклу знов читає час у end. Різницю секунд та наносекунд конвертує в мілісекунди та виводить. Використання монотонного годинника гарантує коректне вимірювання навіть при зміні системного часу.
На скріншотах в першому випадку запущено 10млн ітерацій, на другому 100млн ітерацій(час помітно збільшився)
### Результати:

![](task9/task9.png)
### [Код завдання](task9/task.c)




## ЗАВДАННЯ 10:

### Умова:
 Напишіть програму мовою C для створення послідовності випадкових чисел з плаваючою комою у діапазонах:
 (a) від 0.0 до 1.0
 (b) від 0.0 до n, де n — будь-яке дійсне число з плаваючою точкою.
 Початкове значення генератора випадкових чисел має бути встановлене так, щоб гарантувати унікальну послідовність.
Примітка: використання прапорця -Wall під час компіляції є обов’язковим.

### Пояснення та опис програми:
Програма спочатку читає n з аргументів (якщо не вказано – бере 1.0). Використовуючи srand(time(NULL)), гарантується різна послідовність при кожному запуску. Функція rand() повертає ціле в [0, RAND_MAX], яке ділимо на RAND_MAX+1.0, щоб перетворити в дробове [0,1). Для другої серії множимо отримане значення на n, отримуючи числа в [0,n]. Друкуємо по 10 значень обох діапазонів.
### Результати:

![](task10/task10.png)
### [Код завдання](task10/task.c)




## ЗАВДАННЯ 11 (Варіант 14):
### Умова:
Реалізуйте засіб, який дозволяє відновити вилучений файл, якщо доступ до диску не було втрачено повністю.


### Пояснення та опис програми:
Утиліта відкриває образ диска для читання побайтно, використовуючи fread() для кожного байта та зберігаючи попередній у змінній prev. Вона сканує дані в пошуках маркера початку JPEG (0xFF 0xD8) і після його виявлення починає записувати всі байти у файл через fputc(). Коли досягає маркера кінця (0xFF 0xD9), дописує його й завершує обробку. Якщо заголовок не знайдено, програма видаляє створений файл і повідомляє про відсутність JPEG. Код не потребує сторонніх бібліотек, легко компілюється з -Wall і дозволяє відновити вилучений фрагмент, поки дані не перезаписано. В нашому випадку я успішно відновив jpeg фото.
 ### Результати:

![](task11/task11.png)
### [Код завдання](task11/task.c)

