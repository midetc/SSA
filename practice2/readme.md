
## ЗАВДАННЯ 1:

### Умова:

Напишіть програму для визначення моменту, коли time_t закінчиться. Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.


### Пояснення та опис програми:

Ця програма спочатку обчислює максимальне значення time_t на вашій системі, зсуваючи одиницю на розрядність мінус один і віднімаючи одиницю, після чого відображає його як звичну дату за допомогою ctime. Потім до цього граничного значення додається одиниця, щоб показати переповнення і некоректний відлік часу. На 32‑бітних платформах ліміт настає 19 січня 2038 року, а на 64‑бітних межа знаходиться в мільярдах років. Додатково можна за допомогою readelf -S чи objdump -h подивитися секції ELF‑файлу та зрозуміти, як розподілені код, константи та змінні у виконуваному файлі.

### Результати:

![](task1/task1.png)
### [Код завдання](task1/task1.c)


## ЗАВДАННЯ 2:

### Умова:

Розгляньте сегменти у виконуваному файлі.

1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?

Проаналізуйте результати, щоб переконатися, що:

● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.


### Пояснення програми:

Спочатку компілюєте “hello world”, дивитесь ls і size – сегменти .data й .bss пусті. Додаєте глобальний масив без ініціалізації – зростає BSS у size, але файл не збільшується. Ініціалізований масив переходить у .data, і файл більшає. Локальні масиви впливають лише на стек. -g додає дебаг, -O2 зменшує текст.

### Результат роботи:

![](task2/task2_1.png)
### [Код завдання](task2/task2_1.c)



### Пояснення програми:

Коли ви оголошуєте глобальний масив без ініціалізації, він потрапляє до сегмента BSS, який не зберігається в бінарному файлі, а лише резервується під час запуску. Тому розмір виконуваного файлу майже не змінюється, однак обсяг оперативної пам’яті, необхідний для виконання, зростає відповідно до розміру масиву. При завантаженні ОС виділяє й зануляє пам’ять.

### Результат роботи:

![](task2/task2_2.png)
### [Код завдання](task2/task2_2.c)



### Пояснення програми:

Коли глобальний масив оголошується з початковими значеннями, він переходить із сегмента .bss у сегмент .data. Сегмент .data фізично зберігається в бінарному файлі, тому розмір виконуваного файлу зростає на загальний обсяг даних масиву. При завантаженні ОС виділяє пам’ять та ініціалізує її заданими значеннями. Це можна підтвердити командою size, де зросте показник .data і зменшиться .bss до нуля.

### Результат роботи:

![](task2/task2_3.png)
### [Код завдання](task2/task2_3.c)


### Пояснення програми:

Локальні масиви завжди розміщуються в стеку під час виконання, незалежно від того, ініціалізовані вони чи ні. Непочатковий arr1 просто резервує місце в стековому кадрі. Для arr2 компілятор згенерує інструкції, які при запуску заповнять перший елемент значенням 1, а решту обнулать, але самі дані не «лежать» у сегменті .data. Через це розмір бінарника змінюється не через новий сегмент, а лишень трохи зростає код ініціалізації в текстовому сегменті

### Результат роботи:

![](task2/task2_4.png)
### [Код завдання](task2/task2_4.c)


### Пояснення програми:

При компіляції з опцією налагодження (`-g`) до бінарника додається велика кількість символів і структур для дебагу, тому розмір файлу суттєво зростає, хоча сегменти `.text`, `.data` та `.bss` залишаються тих самих розмірів. З іншого боку, увімкнення максимальної оптимізації (`-O3`) дозволяє компілятору вичавити зайві інструкції та скоротити текстовий сегмент, але обсяги сегментів даних і BSS не змінюються. Локальні масиви, незалежно від ініціалізації, розгортаються в стеку під час виконання й не впливають на розміри виконуваного файлу.

### Результат роботи:

![](task2/task2_5_1.png)

![](task2/task2_5_2.png)
### [Код завдання](task2/task2_4.c)


## ЗАВДАННЯ 3:

### Умова:

Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі:
```c
#include <stdio.h>

int main() {
        int i;
        printf(&quot;The stack top is near %p\n&quot;, &amp;i);
        return 0;
}
```
Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси. Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?

*Примітка*: стек може розташовуватися за різними адресами на різних архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями адрес.


### Результати:

![](task3/task3_1.png)
### [Код завдання](task3/task3_1.c)


### Пояснення програми:

Код досліджує розташування різних сегментів пам’яті. Адреса функції `func` показує текстовий сегмент (зберігає машинний код програми). Глобальна змінна `x` з ініціалізацією належить до сегмента DATA, а неініціалізована глобальна змінна `y` — до сегмента BSS. Виділення пам’яті через `malloc` демонструє розташування купи, а адреса локальної змінної `z` показує місце стека. Програма допомагає зрозуміти, як пам’ять організована і використовується різними сегментами.

### Результати:

![](task3/task3_2.png)
### [Код завдання](task3/task3_2.c)



### Пояснення програми:

У коді досліджується, як змінюється розташування вершини стека при виділенні великих локальних масивів. На початку виводиться адреса змінної `i` у `main`, що вказує на початкове розташування стека. Після виклику функції func, де оголошені масиви `arr1` і `arr2`, адреса вершини стека зсувається вниз (у більшість архітектур стек зростає до нижчих адрес). Це ілюструє динамічний характер використання стека під час виконання програми.

### Результати:

![](task3/task3_3.png)
### [Код завдання](task3/task3_3.c)


## ЗАВДАННЯ 4:

### Умова:

Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви
можете:
● Автоматично за допомогою утиліти gstack.
● Вручну за допомогою налагоджувача GDB.
## [Код завдання](task4/task4.c)

## Пояснення програми:

Ця програма ілюструє глибину вкладення викликів: з main вона переходить у foo, потім у bar і нарешті в bar_is_now_closed, причому кожна функція виводить адресу своєї локальної змінної через макрос MSG. Після виклику bar_is_now_closed виконання зупиняється на pause, очікуючи сигналу. Для дослідження стеку процесу можна використати procstat, який негайно видає знімок кадрів стека всіх потоків без взаємодії з користувачем. Натомість GDB забезпечує інтерактивний доступ: він дозволяє переглядати стек, значення змінних, перемикатися між кадрами й виконувати покроковий аналіз коду. Procstat простий і швидкий, а GDB – інструмент для глибокого налагодження, що потребує більше знань. Procstat дає миттєвий знімок стеку, а GDB дозволяє дослідити змінні й стек докладно.
### Результати:

Запуск програми:

![](task4/task4_1.png)

Procstat:

![](task4/task4_2.png)

GDB:

![](task4/task4_3.png)


## ЗАВДАННЯ 5:

### Умова:

Відомо, що при виклику процедур і поверненні з них процесор використовує стек.Чи можна в такій схемі обійтися без лічильника команд (IP), використовуючи замість нього вершину стека? Обґрунтуйте свою відповідь та наведіть приклади.

### [Код завдання](task5/task5_1.c)

### Результати:

![](task5/task5_1.png)

---
---

### [Код завдання](task5/task5_2.c)

### Пояснення програми:

У цьому завданні досліджується, чи можна замінити лічильник команд (Instruction Pointer, IP) вершиною стека при виклику функцій та поверненні з них. 

У першому коді стандартний механізм виклику функцій використовує стек для збереження адреси повернення. При завершенні функції процесор автоматично бере адресу повернення зі стека і оновлює IP для продовження виконання програми. 


У другому коді використовується інструкцію `asm("addq $8, %rsp")`, яка вручну змінює вершину стека без оновлення IP. Це демонструє, що при маніпуляціях зі стеком без відповідної роботи з IP програма може поводитися непередбачувано, оскільки процесор все одно очікує використовувати IP для коректного виконання інструкцій.

Стек і IP виконують різні ролі. Стек використовується для збереження адреси повернення та локальних даних функцій. IP вказує на поточну інструкцію, яку виконує процесор. Заміна IP вершиною стека неможлива без суттєвих змін в архітектурі процесора, оскільки стек не забезпечує послідовності виконання команд.

| **Приклад** | **Особливості** | **Результат** |
|-----------------------------|-------------------------------|----------------------------------------------|
| **Базовий виклик функції** | Стандартний виклик функції зі збереженням адреси повернення в стеку. | Повернення в `main()` працює коректно, оскільки IP оновлюється автоматично. |
| **Маніпуляція зі стеком** | Використання інструкції `asm` для ручного зміщення вершини стека. | Порушення виконання програми: процесор втрачає правильну адресу повернення через некоректний IP. |


### Результати:

![](task5/task5_2.png)

## ЗАВДАННЯ ПО ВАРІАНТАХ (7 ВАРІАНТ):

### Умова:

Створіть програму, що змінює права доступу до сегментів пам’яті (mprotect).

### [Код завдання](task6/task6.c)

### Пояснення програми:

У цій програмі демонструється використання функції `mprotect` для зміни прав доступу до сегментів пам’яті. Спочатку визначається розмір сторінки пам’яті за допомогою функції `sysconf(_SC_PAGESIZE)`. Потім використовується функція `mmap` для створення нового сегмента пам’яті, який дозволяє читання та запис (права `PROT_READ | PROT_WRITE`). У виділений сегмент пам’яті записується рядок `"Hello, memory protection!"` за допомогою функції `strcpy`, і ці дані успішно виводяться на екран. Після цього за допомогою функції `mprotect` права доступу до пам’яті змінюються на "тільки для читання" `(PROT_READ)`. Це означає, що будь-які подальші спроби запису в цей сегмент будуть заборонені. Далі програма демонструє зміну прав доступу на практиці, при спробі змінити дані в пам’яті після обмеження доступу виникає помилка сегментації (`Segmentation fault`), оскільки запис тепер заборонений. Це підтверджує коректність роботи механізму захисту пам’яті. Після завершення роботи пам’ять вивільняється за допомогою функції `munmap`. Таким чином, програма показує, як за допомогою функцій `mmap` і `mprotect` можна ефективно контролювати доступ до пам’яті. Це особливо корисно для захисту чутливих даних від несанкціонованих змін і є важливим елементом забезпечення безпеки в багатьох системах.

### Результати:

![](task6/task6.png)
