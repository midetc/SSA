
## ЗАВДАННЯ 1:

### Умова:

Напишіть програму для визначення моменту, коли time_t закінчиться. Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.


### Пояснення та опис програми:

Ця програма спочатку обчислює максимальне значення time_t на вашій системі, зсуваючи одиницю на розрядність мінус один і віднімаючи одиницю, після чого відображає його як звичну дату за допомогою ctime. Потім до цього граничного значення додається одиниця, щоб показати переповнення і некоректний відлік часу. На 32‑бітних платформах ліміт настає 19 січня 2038 року, а на 64‑бітних межа знаходиться в мільярдах років. Додатково можна за допомогою readelf -S чи objdump -h подивитися секції ELF‑файлу та зрозуміти, як розподілені код, константи та змінні у виконуваному файлі.

### Результати:

![](task1/task1.png)
### [Код завдання](task1/task1.c)


## ЗАВДАННЯ 2:

### Умова:

Розгляньте сегменти у виконуваному файлі.

1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?

Проаналізуйте результати, щоб переконатися, що:

● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.


### Пояснення програми:

Спочатку компілюєте “hello world”, дивитесь ls і size – сегменти .data й .bss пусті. Додаєте глобальний масив без ініціалізації – зростає BSS у size, але файл не збільшується. Ініціалізований масив переходить у .data, і файл більшає. Локальні масиви впливають лише на стек. -g додає дебаг, -O2 зменшує текст.

### Результат роботи:

![](task2/task2_1.png)
### [Код завдання](task2/task2_1.c)



### Пояснення програми:

Коли ви оголошуєте глобальний масив без ініціалізації, він потрапляє до сегмента BSS, який не зберігається в бінарному файлі, а лише резервується під час запуску. Тому розмір виконуваного файлу майже не змінюється, однак обсяг оперативної пам’яті, необхідний для виконання, зростає відповідно до розміру масиву. При завантаженні ОС виділяє й зануляє пам’ять.

### Результат роботи:

![](task2/task2_2.png)
### [Код завдання](task2/task2_2.c)



### Пояснення програми:

Коли глобальний масив оголошується з початковими значеннями, він переходить із сегмента .bss у сегмент .data. Сегмент .data фізично зберігається в бінарному файлі, тому розмір виконуваного файлу зростає на загальний обсяг даних масиву. При завантаженні ОС виділяє пам’ять та ініціалізує її заданими значеннями. Це можна підтвердити командою size, де зросте показник .data і зменшиться .bss до нуля.

### Результат роботи:

![](task2/task2_3.png)
### [Код завдання](task2/task2_3.c)


### Пояснення програми:

Локальні масиви завжди розміщуються в стеку під час виконання, незалежно від того, ініціалізовані вони чи ні. Непочатковий arr1 просто резервує місце в стековому кадрі. Для arr2 компілятор згенерує інструкції, які при запуску заповнять перший елемент значенням 1, а решту обнулать, але самі дані не «лежать» у сегменті .data. Через це розмір бінарника змінюється не через новий сегмент, а лишень трохи зростає код ініціалізації в текстовому сегменті

### Результат роботи:

![](task2/task2_4.png)
### [Код завдання](task2/task2_4.c)


### Пояснення програми:

При компіляції з опцією налагодження (`-g`) до бінарника додається велика кількість символів і структур для дебагу, тому розмір файлу суттєво зростає, хоча сегменти `.text`, `.data` та `.bss` залишаються тих самих розмірів. З іншого боку, увімкнення максимальної оптимізації (`-O3`) дозволяє компілятору вичавити зайві інструкції та скоротити текстовий сегмент, але обсяги сегментів даних і BSS не змінюються. Локальні масиви, незалежно від ініціалізації, розгортаються в стеку під час виконання й не впливають на розміри виконуваного файлу.

### Результат роботи:

![](task2/task2_5_1.png)

![](task2/task2_5_2.png)
### [Код завдання](task2/task2_4.c)


## ЗАВДАННЯ 3:

### Умова:

Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі:
```c
#include <stdio.h>

int main() {
        int i;
        printf(&quot;The stack top is near %p\n&quot;, &amp;i);
        return 0;
}
```
Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси. Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?

*Примітка*: стек може розташовуватися за різними адресами на різних архітектурах та різних ОС. Хоча ми говоримо про вершину стека, на більшості процесорів стек зростає вниз, до пам’яті з меншими значеннями адрес.


### Результати:

![](task3/task3_1.png)
### [Код завдання](task3/task3_1.c)


### Пояснення програми:

Код досліджує розташування різних сегментів пам’яті. Адреса функції `func` показує текстовий сегмент (зберігає машинний код програми). Глобальна змінна `x` з ініціалізацією належить до сегмента DATA, а неініціалізована глобальна змінна `y` — до сегмента BSS. Виділення пам’яті через `malloc` демонструє розташування купи, а адреса локальної змінної `z` показує місце стека. Програма допомагає зрозуміти, як пам’ять організована і використовується різними сегментами.

### Результати:

![](task3/task3_2.png)
### [Код завдання](task3/task3_2.c)



### Пояснення програми:

У коді досліджується, як змінюється розташування вершини стека при виділенні великих локальних масивів. На початку виводиться адреса змінної `i` у `main`, що вказує на початкове розташування стека. Після виклику функції func, де оголошені масиви `arr1` і `arr2`, адреса вершини стека зсувається вниз (у більшість архітектур стек зростає до нижчих адрес). Це ілюструє динамічний характер використання стека під час виконання програми.

### Результати:

![](task3/task3_3.png)
### [Код завдання](task3/task3_3.c)


## ЗАВДАННЯ 4:

### Умова:

Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви можете:

● Автоматично за допомогою утиліти gstack.

● Вручну за допомогою налагоджувача GDB.

Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання (Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути pstack). Якщо gstack не працює, використовуйте другий метод – через GDB, як показано нижче. Спочатку подивіться на стек за допомогою gstack(1). Нижче наведений приклад стека bash (аргументом команди є PID процесу):
$ gstack 14654
#0 0x00007f359ec7ee7a in waitpid () from /lib64/libc.so.6
#1 0x000056474b4b41d9 in waitchild.isra ()
#2 0x000056474b4b595d in wait_for ()
#3 0x000056474b4a5033 in execute_command_internal ()
#4 0x000056474b4a5c22 in execute_command ()
#5 0x000056474b48f252 in reader_loop ()
#6 0x000056474b48dd32 in main ()
$
Розбір стека:
    ● Номер кадру стека відображається ліворуч перед символом #.

    ● Кадр #0 – це найнижчий кадр. Читайте стек знизу вверх (тобто від main() – кадр #6 – до waitpid() – кадр #0).

    ● Якщо процес багатопотоковий, gstack покаже стек кожного потоку окремо.

Аналіз стека в режимі користувача через GDB

Щоб переглянути стек процесу вручну, використовуйте GDB, приєднавшись до процесу. Нижче наведена невелика тестова програма на C, що виконує кілька вкладених викликів функцій. Граф викликів виглядає так:

    main() --&gt; foo() --&gt; bar() --&gt; bar_is_now_closed() --&gt; pause()

Системний виклик pause() – це приклад блокуючого виклику. Він переводить викликаючий процес у сплячий режим, очікуючи (або блокуючи) сигнал. У цьому випадку процес блокується, поки не отримає будь-який сигнал.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

#define MSG &quot;In function %20s; &amp;localvar = %p\n&quot;

static void bar_is_now_closed(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    printf("\n Now blocking on pause()...\n");

    pause();
}

static void bar(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    bar_is_now_closed();
}

static void foo(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    bar();
}

int main(int argc, char **argv) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    foo();
    exit(EXIT_SUCCESS);
}
```

![](condition4.png)

Тепер відкрийте GDB

У ньому підключіться (attach) до процесу (в наведеному прикладі PID = 24957) і дослідіть стек за допомогою команди backtrace (bt):

$ gdb --quiet
(gdb) attach 24957
Attaching to process 24957
Reading symbols from &lt;...&gt;/hspl/unit2/stacker...done.
Reading symbols from /lib64/libc.so.6...Reading symbols from
/usr/lib/debug/usr/lib64/libc-2.26.so.debug...done.
done.
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols
...
(gdb) bt
...

Примітка: В Ubuntu, через питання безпеки, GDB не дозволяє підключатися до довільного процесу. Це можна обійти, запустивши GDB від імені користувача root.

Аналіз того ж процесу через gstack

$ gstack 24957
...

gstack — це, по суті, оболонковий скрипт (wrapper shell script), який неінтерактивно викликає GDB і запускає команду backtrace, яку ви щойно використали. Завдання: Ознайомтеся з виводом gstack і порівняйте його з GDB.

## [Код завдання](task4/task4.c)

## Пояснення програми:

Програма демонструє вкладені виклики функцій із передачею керування через `main()`, `foo()`, `bar()` та `bar_is_now_closed()` і подальше блокування на системному виклику `pause()`. Кожна функція виводить адресу своєї локальної змінної, дозволяючи відстежувати зміни в стеку. Завдання передбачає дослідження стеку процесу за допомогою інструментів procstat та GDB для порівняння їхньої функціональності.

| **Інструмент** | **Особливості** | **Результати аналізу** |
|-------------------|----------------------|------------------------------------------------------------|
| **Procstat** | Простий інструмент для отримання інформації про стек процесу. Виводить стек усіх потоків у неінтерактивному режимі. | Показує список функцій і точне розташування кожного кадру стека в пам'яті. Використовується для швидкого аналізу багатопоточних програм. |
| **GDB** | Інтерактивний налагоджувач, який дозволяє підключитися до процесу і виконувати різні діагностичні команди. | Дозволяє детально аналізувати стек, а також переглядати змінні й виконувати покадрове дослідження коду. Використовується для детального дебагу. |

| **Критерій** | **Procstat** | **GDB** |
|--------------------------|-------------------------------------------|-------------------------------------------|
| **Режим роботи** | Неінтерактивний | Інтерактивний |
| **Інформація про стек** | Тільки знімок стеку | Знімок стеку + змінні та виконання коду |
| **Підтримка багатопотоковості** | Показує стек кожного потоку окремо | Дозволяє аналізувати окремі потоки вручну |
| **Складність використання** | Простий | Потребує більше знань |
| **Призначення** | Швидкий огляд | Глибокий аналіз |

### Результати:

Запуск програми:

![](task4/task4.png)

Procstat:

![](task4/task4_1.png)

GDB:

![](task4/task4_2.png)


## ЗАВДАННЯ 5:

### Умова:

Відомо, що при виклику процедур і поверненні з них процесор використовує стек.Чи можна в такій схемі обійтися без лічильника команд (IP), використовуючи замість нього вершину стека? Обґрунтуйте свою відповідь та наведіть приклади.

### [Код завдання](task5/task5_1.c)

### Результати:

![](task5/task5_1.png)

---
---

### [Код завдання](task5/task5_2.c)

### Пояснення програми:

У цьому завданні досліджується, чи можна замінити лічильник команд (Instruction Pointer, IP) вершиною стека при виклику функцій та поверненні з них. 

У першому коді стандартний механізм виклику функцій використовує стек для збереження адреси повернення. При завершенні функції процесор автоматично бере адресу повернення зі стека і оновлює IP для продовження виконання програми. 


У другому коді використовується інструкцію `asm("addq $8, %rsp")`, яка вручну змінює вершину стека без оновлення IP. Це демонструє, що при маніпуляціях зі стеком без відповідної роботи з IP програма може поводитися непередбачувано, оскільки процесор все одно очікує використовувати IP для коректного виконання інструкцій.

Стек і IP виконують різні ролі. Стек використовується для збереження адреси повернення та локальних даних функцій. IP вказує на поточну інструкцію, яку виконує процесор. Заміна IP вершиною стека неможлива без суттєвих змін в архітектурі процесора, оскільки стек не забезпечує послідовності виконання команд.

| **Приклад** | **Особливості** | **Результат** |
|-----------------------------|-------------------------------|----------------------------------------------|
| **Базовий виклик функції** | Стандартний виклик функції зі збереженням адреси повернення в стеку. | Повернення в `main()` працює коректно, оскільки IP оновлюється автоматично. |
| **Маніпуляція зі стеком** | Використання інструкції `asm` для ручного зміщення вершини стека. | Порушення виконання програми: процесор втрачає правильну адресу повернення через некоректний IP. |


### Результати:

![](task5/task5_2.png)

## ЗАВДАННЯ ПО ВАРІАНТАХ (7 ВАРІАНТ):

### Умова:

Створіть програму, що змінює права доступу до сегментів пам’яті (mprotect).

### [Код завдання](task6/task6.c)

### Пояснення програми:

У цій програмі демонструється використання функції `mprotect` для зміни прав доступу до сегментів пам’яті. Спочатку визначається розмір сторінки пам’яті за допомогою функції `sysconf(_SC_PAGESIZE)`. Потім використовується функція `mmap` для створення нового сегмента пам’яті, який дозволяє читання та запис (права `PROT_READ | PROT_WRITE`). У виділений сегмент пам’яті записується рядок `"Hello, memory protection!"` за допомогою функції `strcpy`, і ці дані успішно виводяться на екран. Після цього за допомогою функції `mprotect` права доступу до пам’яті змінюються на "тільки для читання" `(PROT_READ)`. Це означає, що будь-які подальші спроби запису в цей сегмент будуть заборонені. Далі програма демонструє зміну прав доступу на практиці, при спробі змінити дані в пам’яті після обмеження доступу виникає помилка сегментації (`Segmentation fault`), оскільки запис тепер заборонений. Це підтверджує коректність роботи механізму захисту пам’яті. Після завершення роботи пам’ять вивільняється за допомогою функції `munmap`. Таким чином, програма показує, як за допомогою функцій `mmap` і `mprotect` можна ефективно контролювати доступ до пам’яті. Це особливо корисно для захисту чутливих даних від несанкціонованих змін і є важливим елементом забезпечення безпеки в багатьох системах.

### Результати:

![](task6/task6.png)
