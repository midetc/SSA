## ЗАВДАННЯ З ЛЕКЦІЇ №2.3 :
### Пояснення та опис програми:
Програма створює два процеси — батьківський та дочірній. Спочатку виконується виклик fork(), який дублює поточний процес. Якщо fork повертає від’ємне значення, консоль виводить повідомлення про помилку fork failed. Якщо fork повертає нуль, запускається дочірній процес і з’являється повідомлення This is the child process. Якщо fork повертає додатній PID дочірнього, виконується батьківський процес і виводиться This is the parent process. У результаті одночасно з’являються обидва повідомлення, що ілюструє розгалуження виконання в Unix-подібних системах.
### Результати:
![](task2.3/1.png)
### [Код завдання](task2.3/task.c)



## ЗАВДАННЯ З ЛЕКЦІЇ №2.4 :
### Пояснення та опис програми:
Ця програма спочатку викликає fork(), створюючи два процеси — батьківський та дочірній. Далі обидва процеси виконують однаковий цикл від 0 до 4. На кожній ітерації батьківський процес виводить «Parent: i», а дочірній — «Child: i», де i — поточне значення лічильника. Через механізм планування ОС повідомлення можуть з’являтися в довільному порядку, тому рядки від обох процесів чергуються. В результаті на екрані з’являються по черзі записи з числами від 0 до 4 від кожного процесу. Цей простий приклад показує, як fork() дозволяє одній програмі розгалужуватися на два незалежні потоки виконання.
### Результати:

![](task2.4/1.png)
### [Код завдання](task2.4/task.c)




## ЗАВДАННЯ З ЛЕКЦІЇ №2.5 :
### Пояснення та опис програми:
Програма створює два процеси за допомогою виклику fork(): батьківський і дочірній. Обидва процеси спочатку мають змінну counter зі значенням 0. Дочірній процес відразу збільшує counter на одиницю і виводить «Child: counter = 1». Батьківський процес чекає секунду (функція sleep(1)), щоб дочірній встиг виконатися, а потім виводить «Parent: counter = 0», адже в батьківському екземплярі змінна не змінилася. Через розгалуження кожен процес працює зі своєю копією пам’яті, тому збільшення лічильника в одному процесі не впливає на інший. Цей приклад ілюструє незалежність даних між батьківським та дочірнім процесами.
### Результати:

![](task2.5/1.png)
### [Код завдання](task2.5/task.c)




## ЗАВДАННЯ З ЛЕКЦІЇ №2.6 :
### Пояснення та опис програми:
Ця програма відкриває (або створює й очищає) файл test.txt і відразу робить fork(), внаслідок чого з’являються два процеси з одним файловим дескриптором і спільним зміщувачем. Дочірній процес виконує запис «Child\n» у файл, рухаючи позицію вперед на 6 байт, а батьківський — записує «Parent\n», дописуючи ще 7 байт. Через те, що зміщувач спільний, один процес пише першим, а інший — відразу після нього. В результаті в test.txt опиняються два рядки («Child» і «Parent») у тій послідовності, в якій ОС виконала їхні записи.
### Результати:

![](task2.6/1.png)
### [Код завдання](task2.6/task.c)




## ЗАВДАННЯ З ЛЕКЦІЇ №2.7 :
Програма реалізує простий інтерпретатор команд — shell. У головній функції запускається нескінченний цикл, який виводить підказку dumbsh>, зчитує введену користувачем строку і видаляє символ нового рядка. Якщо користувач ввів exit, цикл обривається і програма завершується. В інших випадках виконується fork(): дочірній процес викликає execlp() з іменем введеної команди (і завершується з кодом 1 у разі помилки та повідомлення exec failed), а батьківський процес чекає на завершення дочірнього за допомогою wait(). Потім цикл повторюється, дозволяючи вводити нові команди.
### Пояснення та опис програми:
### Результати:

![](task2.7/1.png)
### [Код завдання](task2.7/task.c)




## ЗАВДАННЯ З ЛЕКЦІЇ №2.9 :
### Пояснення та опис програми:
Програма створює один дочірній процес за допомогою fork(). У дочірньому процесі одразу виконується exit(7), тобто він завершується з кодом виходу 7. Батьківський процес викликає wait(), чекає на завершення дитини й зберігає її статус у змінній status. Після цього перевіряє, чи дитина завершилася нормально (WIFEXITED) і виводить на екран рядок типуChild 1605 exited with code 7, де 1605 – PID дочірнього процесу, а 7 – його код виходу. Цей приклад демонструє передачу коду завершення від дочірнього до батьківського процесу в Unix-подібних системах .
### Результати:

![](task2.9/1.png)
### [Код завдання](task2.9/task.c)



## ЗАВДАННЯ З ЛЕКЦІЇ №2.10:
### Пояснення та опис програми:
Програма виконує трьохкратний цикл і при кожній ітерації створює дочірній процес за допомогою fork(). Дочірній процес одразу виводить на екран “Child i”, де i – його номер в циклі, а потім завершується викликом exit(0). Батьківський процес продовжує ітерації без виведення повідомлень. Після створення всіх трьох дітей батько переходить у цикл очікування wait(NULL), спочатку чекаючи на завершення першого, потім другого і третього дочірнього процесу. У результаті на екрані з’являються три рядки:
Child 0
Child 2
Child 1
(порядок може трохи відрізнятися через планувальник ОС).
### Результати:

![](task2.10/1.png)
### [Код завдання](task2.10/task.c)





## ЗАВДАННЯ З ЛЕКЦІЇ №2.11 :
### Пояснення та опис програми:
Програма створює дочірній процес через fork(). У дочірньому процесі виконується sleep(2), після чого він завершується викликом exit(0). Батьківський процес спочатку чекає завершення будь-якого дочірнього за допомогою wait(NULL), а потім викликає waitpid(-1, &status, 0) — ще один спосіб дочекатися кінця процесу. Оскільки немає жодних викликів printf, у консолі не з’являється жодного виводу. Це демонструє блокуюче очікування завершення процесів у Unix-подібних системах.
### Результати:

![](task2.11/1.png)
### [Код завдання](task2.11/task.c)



## ПЕРСОНАЛЬНЕ ЗАВДАННЯ, ВАРІАНТ №14 :
### Умова: Напишіть дві програми: одна просто виводить повідомлення, інша — викликає її після fork() за допомогою exec().
### Пояснення та опис програми:
Програма складається з двох частин — launcher і printer. Launcher спочатку викликає fork(), щоб створити дочірній процес. У дочірньому процесі замість свого коду запускається виконуваний файл printer через execl(), тому дочірній процес виводить «Hello from printer!» і завершується з кодом 0. Батьківський процес у launcher чекає завершення дитини за допомогою waitpid(), а потім читає її код виходу і виводить «Child exited with code 0». Таким чином демонструється, як один процес може замінити себе іншим і як батько отримує інформацію про результат його роботи.
### Результати:

![](task(V14)/1.png)
### [Код завдання](task(V14)/printer.c)
### [Код завдання](task(V14)/launcher.c)


